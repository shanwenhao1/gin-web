# 领域驱动设计

@[TOC]
- [现代架构设计](#现代架构设计)
    - [CQRS架构](#CQRS架构)
    - [DDD](#DDD)
        - [分层的必要性](#分层的必要性)
        - [DDD采用四层分层](#DDD采用四层分层)
            - [user interface](#user-interface:用户界面层)
            - [application](#application:应用层)
            - [domain](#domain:领域层)
            - [Infrastructure](#Infrastructure:基础层)     
- [](#)
- [](#)
- [](#)

## 现代架构设计

- 核心: 保证面对业务变化时我们能够有足够快的响应能力

- 关键要素
    - 从业务出发、面向业务变化而架构
    - 组件复用及组件之间的低耦合性(保证业务之间的互相独立性从而不会因为一个子模块的崩溃从而影响整个服务)
    
- [传统架构设计的缺点](https://www.cnblogs.com/netfocus/p/5184182.html)
    - 扩展性、可用性不足
    - 性能瓶颈: 传统架构大部分系统都将存储数据到关系型数据库中, 只能采用分库分表的方案.
        
### CQRS架构

- 前言
    - 基于DDD设计, 读写分离的思想, 实现方式多种多样. 
        - 比如数据存储不分离, 仅仅只是代码层面读写分离.
        - 数据存储的读写分离,  C端负责数据存储, Q端负责数据查询Q端的数据通过, C端产生的Event来同步，这种也是CQRS架构的一种实现

- 核心思想是将应用程序的查询部分和命令部分完全分离, 这两部分可以用完全不同的模型和技术去实现, 这样的优点有:
    - 实现命令部分的领域模型不用经常为了领域对象可能会被如何查询而做一些折中处理
    - 由于命令和查询是完全分离的，所以这两部分可以用不同的技术架构实现，包括数据库设计都可以分开设计，
    每一部分可以充分发挥其长处
    - 高性能，命令端因为没有返回值，可以像消息队列一样接受命令，放在队列中，慢慢处理；处理完后，
    可以通过异步的方式通知查询端，这样查询端可以做数据同步的处理

- 扩展性
    - 以[Saga](https://www.cnblogs.com/netfocus/p/3149156.html)的思想, 通过事件驱动的方式, 实现多个聚合根的交互, CQ两端也是通过事件的方式异步进行数据同步
    - 基于EDA思想(传统架构基于SOA思想), 耦合性低因此扩展性较好.
        - SOA: 一个服务调用另外一个服务完成服务之间的交互, 服务之间紧耦合
        - EDA: 一个组件订阅另外一个组件的事件消息, 根据事件信息更新组件自己的状态, 耦合性非常低.
- 可用性
    - 传统架构
        - 因为没有读写分离, 因此性能瓶颈要把读写合在一起考虑, 比较浪费硬件资源 
    - CQRS架构
        - 读写分离, 因此性能瓶颈将读(Q端考虑)或写(C端考虑)分开考虑
        - 任何数据修改时，都会发送Command到分布式消息队列，然后后端消费者处理
        Command->产生领域事件->持久化事件->发布事件到分布式消息队列->最后事件被Q端消费。
        这个链路是消息驱动的。相比传统架构的直接服务方法调用，可用性要高很多。因为就算我们处理Command的后端消费者暂时挂了，
        也不会影响前端Controller发送Command，Controller依然可用。从这个角度来说，CQRS架构在数据修改上可用性要更高。
        - 分布式消息队列属于中间件，一般中间件都具有很高的可用性(支持集群和主备切换), 可用性较高.
        - 由于命令是先发送到分布式消息队列，这样就能充分利用分布式消息队列的优势：异步化、拉模式、削峰填谷、
        基于队列的水平扩展。这些特性可以支持前端Controller发送Command高并发.
        - 一个命令只会修改一个聚合根，如果要修改多个聚合根通过Saga来实现, 绕过了复杂事务的问题, 降低了锁对性能的影响.
        
### DDD

#### 分层的必要性

给复杂的应用程序划分层次, 在每一层内分别进行设计, 使其具有内聚性并且只依赖于它的下层. 采用标准的架构模式, 
只与上层进行松散连接. 领域对象应该将重点放在如何表达领域模型上, 而不需要考虑自己的显示和存储问题, 
也无需管理应用任务等内容.

#### DDD采用四层分层

##### user-interface:用户界面层

##### application:应用层
很薄的一层, 只包含工作流控制逻辑, 不包含业务逻辑.

##### domain:领域层
包含整个应用的所有业务逻辑及领域的信息, 这是业务软件的核心所在

本层包含:
###### 模型: 
三个重要元素
- Entity(实体): 
    - Entity的最基本职责是确保连续性, 以便使其行为更清楚且可预测. 保持实体的简练是关键.
    - 设计Entity时, 应为对象设计一个唯一的标识进行区分. 可以是对象的属性(具有唯一性), 
    或者额外附加一个符号作为唯一标识.
- Value Object
- Service

如何建模:
- 控制关联: 现实中存在大量的"多对多"关联, 且大部分是双向的. 使得维护变得复杂, 因此控制关联就变得非常必要
   - 规定一个遍历方向: 坚持将关联限定为领域中所偏向的方向, 不仅可以提高这些关联的表达力并简化其实现, 
   而且还可以突出剩下的双向关联的重要性.
   - 添加一个限定符, 以便有效地减少多重关联
   - 消除不必要的关联



##### Infrastructure:基础层
- 作为其他层的支撑库存在, 提供了层之间的通信, 实现对业务对象的持久化, 包含对表现层的支持库等作用.
- 该层可以考虑读写分离.

如果一个架构能够把那些与领域相关的代码隔离出来, 得到一个内聚的领域设计, 同时又使领域与系统其它部分保持松散连接, 
那么这种架构也许可以支持领域驱动设计

- 必要点
    -  通用语言
        - 领域模型的最大价值在于它提供了一种通用语言, 将领域专家和技术人员联系在一起.
    - 真正强大的领域模型是随着时间演进的 
# 领域驱动设计

@[TOC]
- [现代架构设计](#现代架构设计)
    - [CQRS架构](#CQRS架构)
    - [DDD](#DDD)
        - [分层的必要性](#分层的必要性)
        - [DDD采用四层分层](#DDD采用四层分层)
            - [user interface](#user-interface:用户界面层)
            - [application](#application:应用层)
            - [domain](#domain:领域层)
            - [Infrastructure](#Infrastructure:基础层)     
- [](#)
- [](#)
- [](#)

## 现代架构设计

- 核心: 保证面对业务变化时我们能够有足够快的响应能力

- 关键要素
    - 从业务出发、面向业务变化而架构
    - 组件复用及组件之间的低耦合性(保证业务之间的互相独立性从而不会因为一个子模块的崩溃从而影响整个服务)
    
- [传统架构设计的缺点](https://www.cnblogs.com/netfocus/p/5184182.html)
    - 扩展性、可用性不足
    - 性能瓶颈: 传统架构大部分系统都将存储数据到关系型数据库中, 只能采用分库分表的方案.
        
### CQRS架构

- 前言
    - 基于DDD设计, 读写分离的思想, 实现方式多种多样. 
        - 比如数据存储不分离, 仅仅只是代码层面读写分离.
        - 数据存储的读写分离,  C端负责数据存储, Q端负责数据查询Q端的数据通过, C端产生的Event来同步，这种也是CQRS架构的一种实现

- 核心思想是将应用程序的查询部分和命令部分完全分离, 这两部分可以用完全不同的模型和技术去实现, 这样的优点有:
    - 实现命令部分的领域模型不用经常为了领域对象可能会被如何查询而做一些折中处理
    - 由于命令和查询是完全分离的，所以这两部分可以用不同的技术架构实现，包括数据库设计都可以分开设计，
    每一部分可以充分发挥其长处
    - 高性能，命令端因为没有返回值，可以像消息队列一样接受命令，放在队列中，慢慢处理；处理完后，
    可以通过异步的方式通知查询端，这样查询端可以做数据同步的处理

- 扩展性
    - 以[Saga](https://www.cnblogs.com/netfocus/p/3149156.html)的思想, 通过事件驱动的方式, 实现多个聚合根的交互, CQ两端也是通过事件的方式异步进行数据同步
    - 基于EDA思想(传统架构基于SOA思想), 耦合性低因此扩展性较好.
        - SOA: 一个服务调用另外一个服务完成服务之间的交互, 服务之间紧耦合
        - EDA: 一个组件订阅另外一个组件的事件消息, 根据事件信息更新组件自己的状态, 耦合性非常低.
- 可用性
    - 传统架构
        - 因为没有读写分离, 因此性能瓶颈要把读写合在一起考虑, 比较浪费硬件资源 
    - CQRS架构
        - 读写分离, 因此性能瓶颈将读(Q端考虑)或写(C端考虑)分开考虑
        - 任何数据修改时，都会发送Command到分布式消息队列，然后后端消费者处理
        Command->产生领域事件->持久化事件->发布事件到分布式消息队列->最后事件被Q端消费。
        这个链路是消息驱动的。相比传统架构的直接服务方法调用，可用性要高很多。因为就算我们处理Command的后端消费者暂时挂了，
        也不会影响前端Controller发送Command，Controller依然可用。从这个角度来说，CQRS架构在数据修改上可用性要更高。
        - 分布式消息队列属于中间件，一般中间件都具有很高的可用性(支持集群和主备切换), 可用性较高.
        - 由于命令是先发送到分布式消息队列，这样就能充分利用分布式消息队列的优势：异步化、拉模式、削峰填谷、
        基于队列的水平扩展。这些特性可以支持前端Controller发送Command高并发.
        - 一个命令只会修改一个聚合根，如果要修改多个聚合根通过Saga来实现, 绕过了复杂事务的问题, 降低了锁对性能的影响.
        
### DDD

#### 分层的必要性

给复杂的应用程序划分层次, 在每一层内分别进行设计, 使其具有内聚性并且只依赖于它的下层. 采用标准的架构模式, 
只与上层进行松散连接. 领域对象应该将重点放在如何表达领域模型上, 而不需要考虑自己的显示和存储问题, 
也无需管理应用任务等内容.

#### DDD采用四层分层

##### user-interface:用户界面层

##### application:应用层
很薄的一层, 只包含工作流控制逻辑, 不包含业务逻辑.

##### domain:领域层
包含整个应用的所有业务逻辑及领域的信息, 这是业务软件的核心所在

本层包含:
###### 模型: 

Entity(实体): 
- Entity的最基本职责是确保连续性, 以便使其行为更清楚且可预测. 保持实体的简练是关键.
- 设计Entity时, 应为对象设计一个唯一的标识进行区分. 可以是对象的属性(具有唯一性), 
或者额外附加一个符号作为唯一标识.

Value Object(值对象):
- 用于描述领域的某个方面而本身没有概念标识的对象称为Value Object(值对象)
- 当我们只关心一个模型元素的属性时, 应把它归类为Value Object.
- 跟踪Entity的标识是非常重要的, 但为其他对象也加上标识会影响系统性能并增加分析工作, 而且会使得模型变得混乱, 
  因为所有对象看起来都是相同的.
- 复制和共享: 根据环境选择, 复制会导致系统被大量的对象阻塞, 共享会减慢分布式系统的速度.
    - 共享实例优化性能(需谨慎考虑, 因为牵一发而动全身, 这种可共享的value object应该都是不变的).使用共享的情况:
        - 当节省数据空间或减少对象数量是一个关键要求时
        - 当通信开销很低时(例如在中央服务器中)
        - 当共享的对象被严格限定为不可变时
        
Service: 所谓Service, 它强调的是与其他对象的关系, service本质上是一些活动或动作, 而不是事物.
- 当领域中的某个重要的过程或转换操作不属于实体或值对象的自然职责时, 应该在模型中添加一个作为独立接口的操作, 
  并将其声明为Service.
- 好的service有以下三个特征:
    - 与领域概念相关的操作不是Entity或Value Object的一个自然的部分.
    - 接口是根据领域模型的其他元素定义的
    - 操作是无状态的(任何客户都可以使用某个service的任何实例, 而不必关心该实例的历史状态)
- service可以划分到各个层中. 通过不同层的service配合, 从而控制领域层中的接口的粒度, 并且避免客户与Entity和Value Object的耦合.

如何建模:
- 控制关联: 现实中存在大量的"多对多"关联, 且大部分是双向的. 使得维护变得复杂, 因此控制关联就变得非常必要
   - 规定一个遍历方向: 坚持将关联限定为领域中所偏向的方向, 不仅可以提高这些关联的表达力并简化其实现, 
   而且还可以突出剩下的双向关联的重要性.
   - 添加一个限定符, 以便有效地减少多重关联
   - 消除不必要的关联
   
Module(模块): 
- 模块的出现,就是为了组织统一的模型概念来达到减少复杂性的目的的.
- Module之间是低耦合的, 内部是高内聚的.可以提高代码质量和可维护性

###### 领域对象的生命周期

使用Factory创建和重建复杂对象, 并使用Aggregate来封装它们的内部结构, 最后使用Repository来提供
查找和检索持久对象并封装庞大基础设施的手段.

Aggregates(聚合):
- 什么是聚合?: 
    - AGGREGATE就是一组相关对象的集合, 作为数据修改的单元. 每个AGGREGATE都有一个根(一个特定的Entity, 是AGGREGATE中唯一允许被
    外部对象引用的元素)和一个边界(边界定义了AGGREGATE内部都有什么)
- 为什么要用聚合?:
    - 想想数据库中删除一个Person对象, 连带删除的还有姓名等. 但如果有共享的数据呢?(比如地址), 如果只是
    连带删除地址, 那其他的Person就会出错. 如果不删除, 则会造成数据库垃圾碎片过多.因此引入聚合的概念, 
    来作为数据修改的单元.
- 聚合的规则:
    - 根Entity具有全局标识, 它负责检查固定规则.
    - 边界内的Entity具有本地标识(比如汽车的轮胎), 这些标识只有在Aggregates内部才是唯一的.
    - Aggregate外部的对象不能引用除根Entity之外的任何内部对象. 根Entity可以把对内部Entity的引用传递给它们,
    但这些对象只能临时使用这些引用, 不能保持.
    - 删除操作必须一次删除Aggregate边界之内的所有对象(利用垃圾回收机制)
    - 当提交对Aggregate边界内部的任何对象修改时, 整个Aggregate中的所有固定规则都必须被满足.

Factory: 
- 当创建一个对象或创建整个AGGREGATE时, 如果创建工作很复杂, 或者暴露了过多的内部结构, 则可以使用Factory进行封装.
- 好的工厂需要满足两个基本需求:
    - 每个创建方法都是原子方法, 而且满足被创建对象或AGGREGATE的所有固定规则.
    - Factory应该被抽象为所需的类型, 而不是创建出具体的类.

Repository:
- 只为那些确实需要直接访问的AGGREGATE根提供Repository, 将所有对象存储和访问操作交给Repository ,从而让客户始终聚焦于模型.
- 客户需要以一种符合实际的方式来获取对已存在的领域对象的引用. 如果基础设施随随便便就允许开发人员获得这些引用, 那么他们
  可能会增加很多可遍历的关联, 这会使模型变得非常混乱. 另一方面, 开发人员可能使用查询从数据库中提取他们所需的数据, 或是直接
  提取几个具体的对象, 而不是通过从AGGREGATE根开始导航来得到这些对象. 这样会导致领域逻辑泄露到查询和客户代码中, 而且
  Entity和Value Object变成为单纯的数据容器. 大多数用于数据库访问的基础设施的技术复杂性很快就会使客户代码变得混乱, 这将导致
  开发人员放弃领域层, 最后使得模型变得无关紧要.
- 优点:
    - 它们为客户提供了一个简单的模型, 可用来获取持久对象并管理它们的生命周期
    - 它们使应用程序和领域设计与持久化技术(多种数据库策略甚至是多个数据源)解耦
    - 它们体现了有关对象访问的设计决策
    - 可以很容易将它们替换为"哑实现"(dummy implementation), 以便在测试中使用.
- 注意点:
    - 对类型进行抽象
    - 充分利用Repository与客户解耦的优点: 在Repository中使用不同的查询技术, 或在内存中缓存对象优化性能.
    - 将事务的控制权留给客户
    
Repository与Factory的关系:
- Factory负责处理对象生命周期的开始, 而Repository帮助管理生命周期的中间和结束
- 从领域驱动设计角度来看, Factory负责制造新对象, 而Repository负责查找已有对象.


###### 示例: pdf 130页 

- Cargo: 货物, Customer: 客户, Specification: 规格, Carrier Movement: 运输动作, 
Handling Event: 处理事件(装货、卸货、收货人提货), Delivery Specification: 运送规格
![](picture/domain%20example%201.png)
![](picture/domain%20example%202.png)

- 应用层: 是协调者, 只负责提问, 而不负责回答, 回答是领域层的工作.
    - Tracking Query(跟踪查询): 访问某个Cargo过去和现在的处理状况
    - Booking Application(预定应用): 允许注册一个新的Cargo, 并使系统准备好处理它
    - Incident Logging Application(事件日志应用): 记录对Cargo的每次处理(提供通过Tracking Query找到的信息)

##### Infrastructure:基础层
- 作为其他层的支撑库存在, 提供了层之间的通信, 实现对业务对象的持久化, 包含对表现层的支持库等作用.
- 该层可以考虑读写分离.

如果一个架构能够把那些与领域相关的代码隔离出来, 得到一个内聚的领域设计, 同时又使领域与系统其它部分保持松散连接, 
那么这种架构也许可以支持领域驱动设计

- 必要点
    -  通用语言
        - 领域模型的最大价值在于它提供了一种通用语言, 将领域专家和技术人员联系在一起.
    - 真正强大的领域模型是随着时间演进的 